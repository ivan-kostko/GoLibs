//   Copyright (c) 2016 Ivan A Kostko (github.com/ivan-kostko)

//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at

//       http://www.apache.org/licenses/LICENSE-2.0

//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

//// DO NOT EDIT. It is auto-generated code! ////

package {{ .PackageName }}

import (
	"fmt" // just to Sprintf error messages
	. "github.com/ivan-kostko/GoLibs/CustomErrors"
	ds "github.com/windelnde/Go-Libs/DataSource"
)

const (
	ERR_FAILEDGENERATEINSTRUCTION   = "DataSource/{{ .PackageName }}: Failed to generate instruction due to error: %v"
	ERR_FAILEDEXECUTEINSTRUCTION    = "DataSource/{{ .PackageName }}: Failed to execute instruction due to error: %v"
	ERR_FAILEDPROCESSTHERESULT      = "DataSource/{{ .PackageName }}: Failed to process execution result due to error: %v"
	ERR_NOTIMPLEMENTEDFUNCTIONALITY = "DataSource/{{ .PackageName }}: aparently the functionality is not yet implemented"
)

// Represents data provider.
// Actualy is a wrapper for net/http Client
type DataProvider func(Instruction) (Result, *Error)

// Represents translator from FilteringCondition into concreet provider instruction
type GetterInstructionGenerator func(fc ds.FilteringCondition) (Instruction, *Error)

// Represents translator from item into concreet provider instruction
type StorerInstructionGenerator func(item interface{}) (Instruction, *Error)

// Represnts converter from Result into DataSource.ResultSet
type ResultProcessor func(result Result) (ds.ResultSet, *Error)

// {{ .PackageName }} implementation of DataSource interface.
type DataSource struct {
	getterInstructionGenerator GetterInstructionGenerator
	storerInstructionGenerator StorerInstructionGenerator
	dataProvider               DataProvider
	resultProcessor            ResultProcessor

	// It is executed on critical errors. So, it is easy to introduce log,
	// debug or whatever functionality to catch errors.
	OnCriticalError func(*Error)
}

// Implements github.com/windelnde/Go-Libs/DataSource GetterDataSource
func (this *DataSource) Get(fc ds.FilteringCondition) (ds.ResultSet, *Error) {
	if this.getterInstructionGenerator == nil {
		return nil, NewError(Nonsupported, ERR_NOTIMPLEMENTEDFUNCTIONALITY)
	}
	instruction, err := this.getterInstructionGenerator(fc)
	if err != nil {
		this.OnCriticalError(err)
		return nil, NewError(InvalidOperation, fmt.Sprintf(ERR_FAILEDGENERATEINSTRUCTION, err))
	}
	return this.executeInstruction(instruction)
}

// Implements github.com/windelnde/Go-Libs/DataSource StorerDataSource
func (this *DataSource) Store(item interface{}) (ds.ResultSet, *Error) {
	if this.storerInstructionGenerator == nil {
		return nil, NewError(Nonsupported, ERR_NOTIMPLEMENTEDFUNCTIONALITY)
	}
	instruction, err := this.storerInstructionGenerator(item)
	if err != nil {
		this.OnCriticalError(err)
		return nil, NewError(InvalidOperation, fmt.Sprintf(ERR_FAILEDGENERATEINSTRUCTION, err))
	}
	return this.executeInstruction(instruction)
}

func (this *DataSource) executeInstruction(instruction Instruction) (ds.ResultSet, *Error) {
	result, err := this.dataProvider(instruction)
	if err != nil {
		this.OnCriticalError(err)
		return nil, NewError(InvalidOperation, fmt.Sprintf(ERR_FAILEDEXECUTEINSTRUCTION, err))
	}
	resultSet, err := this.resultProcessor(result)
	if err != nil {
		this.OnCriticalError(err)
		return nil, NewError(InvalidOperation, fmt.Sprintf(ERR_FAILEDEXECUTEINSTRUCTION, err))
	}
	return resultSet, nil
}